## Shell Sort (diminishing Incremental)
*TODO: Look into this and review when it might be useful*
Takes a log number of passes, but not n number of passes. The worst and best case are always the same. Theta(n^1.5). It is NOT a stable algorithm, however. 

## Bucket Sort
Pass through a file, but put them in location not based on digit. Instead, use a preset size, like 20, 50, or 100. Its a little more error prone, but radix sort is an implementation of this.

Stable, if implemented correctly. 
## Radix Sort
Radix means base. Group digits that have the share the same significant position. Sort by the digit one column at a time. Starts at the least significant digit (right to left). 

Radix sort does NO comparisons. Instead, you compare a digit, not a key. It cannot be compared to the other sorting algorithms in the same way. 

## Hybrid Sort
Say you have a list thats MILLIONS of records long. Begin with quick sort, then do something dumb on the smaller pieces, like bubble sort. They're usually more complicated. 

# Quicksort - a closer look
Traditional: Take the key on left hand side of file, compare to second and move it. 
Median, of Medians is the key to make quick sort O(nlogn)
### An Overview of Average Case Analysis
- Assume keys are distinct. Stability is not an issue. 
- Assume all permutations are equally likely. 

Let F(n) denote the average number of key comparisons required by quicksort. Then

$F(n) = (n-1) + (1/n)*\sum{i=1}{n}[F(i-1) + F(n-i)]$ which by symmetry $= (n-1)  + (2/n)\sum{i=1}{n}[F(i-1)]$

This is a first order inhomogeneous recurrence. It required a change of variable, using asymptotic to convert the series to an integral, to find that $1.39 * n log_2 n$. It has the lowest constant of proportionality on average. This is why we use quick sort

### Back to the worst case (the pivot sucks ass)
- The average case relies on iffy assumptions, and doesn't address the worst case. 
- The worst-case does not rely on our previous assumptions. 

What pivot is the best? 
- Something close to the median. 

Best Algorithm to find the optimal median? 
- find the smallest value, until you find the n/2 smallest. (BAD O(N^2))
- Sort the file, use the item at n/2. (Sort to Sort? bad idea). 
- Pseudo-randomly pick a small set of elements (use the median as a proxy) (~3 usually, works but still has the same worst case). 
- Break the file into subfiles, for each subfile find the median, and compute the median of medians. 
	- Chose an odd number r > 1 (5 is a good choice). 
	- Divide L into $\frac{n}{r}$ subfiles. 
	- Find the median of each subfile. 
	- Find the median of the medians. Recur?


