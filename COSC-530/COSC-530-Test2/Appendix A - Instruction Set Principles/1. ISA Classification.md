
| Stack  | Accumulator | Register (register-memory) | Register (load-store) |
|---------|--------------|----------------------------|------------------------|
| Push A  | Load A       | Load R1, A                 | Load R1, A             |
| Push B  | Add B        | Add R3, R1, B              | Load R2, B             |
| Add     | Store C      | Store R3, C                | Add R3, R1, R2         |
| Pop C   |              |                            | Store R3, C            |
*Table 1: Example code for each type of ISA*
# Stack Architectures 
Stack (zero address) Architectures do not contain registers. Instead, instructions implicitly access their operands on a stack. 

C = A + B
Push A
Push B
Add
Pop C

# Accumulator Machines
Use a single register to address operands, accumulate the results of operations in an accumulator register. 

C = A + B
Load A
Add B
Store C

# General Purpose Register Architectures
## 2-address
C = A + B
load R1, A
add R3, R1, B // Add R1 and Memory address B, store in R3
Store R3, C

## 3-address
C = A + B
Load R1, A
Load R2, B
add R3, R1, R2 // use 3 registers for operands, one for storage, two for arguements
store R, C

| Number of Memory Addresses | Maximum Operands Allowed | Type of Architecture           | Examples                 |
| -------------------------- | ------------------------ | ------------------------------ | ------------------------ |
| 0                          | 3                        | Register-Register (load-store) | ARM, MIPS, RISC-V, SPARC |
| 1                          | 2                        | Register-Memory                | IBM 370, Intel x86       |
| 2                          | 2                        | Memory-Memory                  | VAX                      |
| 3                          | 3                        | Memory-Memory                  | VAX                      |
### Register-Register Architectures
Only load and store instructions can access memory directly; corresponds to 3 address example. 

**Advantages**: Simple, fixed-length instruction encoding. Simple code generation, and instructions are consistent in clocks to execute.

**Disadvantage**: higher instruction count than other architectures, leading to larger programs which may have some instruction cache effects. 
### Memory-Register Architectures
Memory can be accessed as part of the instruction; corresponds to 2 address example. 

**Advantages**: Data can be accessed without a separate load instruction, tends to be easy to decode and yeilds good density. 

**Disadvantages**: Operands are not equivalent because a source operand in a binary operation is destroyed. Clocks per instruction vary from operand to operand.
### Memory-Memory Architectures
Not used today, but used by older vax systems. All operands are performed in memory. 

**Advantages**: Very compact, does not waste registers.

**Disadvantages**: large variation in instruction size, especially for operands with three parameters. Memory accesses create a bottleneck. 