# Register Addressing

Performs operands directly from one of the CPU's registers. 
**Example**: Add R4, R3
# Immediate Addressing

The operand is performed on a constant value as part of the instruction itself.
**Example**: Add R3, 3 // Add 3 to the value in R3

# Displacement Addressing

Determine the memory address for an operand through an offset.
**Example**: Add R4, 100(R1) *adds 100 to the address at R1, go to that address, fetch its value, and add it to R4*

## Register Indirect Addressing

Essentially an indirect-pointer dereference; access the value at the memory address corresponding with a register;
**Example**: Add R4, (R1) *finds the address R1 stores, and access the value at the memory address*

# Indexed Addressing

Similar to displacement, but the offset is stored in a register instead of a constant; 
**Example**: Add R3, (R1 + R2) // R2 is the offset

# Direct/Absolute Addressing

Accesses memory addresses directly, just the hard-coded address;
**Example**: Add R1, (1001) // add the value at memory address 1001

# Memory Indirect Addressing

References memory through a pointer held in memory. 
**Example**: Add R1, @(R3)

| **Addressing mode**    | **Example instruction** | **Meaning**                                                        | **When used**                                                                                                                             |
| ---------------------- | ----------------------- | ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **Register**           | `Add R4, R3`            | `Regs[R4] <- Regs[R4] + Regs[R3]`                                  | When a value is in a register                                                                                                             |
| **Immediate**          | `Add R4, 3`             | `Regs[R4] <- Regs[R4] + 3`                                         | For constants                                                                                                                             |
| **Displacement**       | `Add R4, 100(R1)`       | `Regs[R4] <- Regs[R4] + Mem[100 + Regs[R1]]`                       | Accessing local variables (+ simulates register indirect, direct addressing modes)                                                        |
| **Register indirect**  | `Add R4, (R1)`          | `Regs[R4] <- Regs[R4] + Mem[Regs[R1]]`                             | Accessing using a pointer or a computed address                                                                                           |
| **Indexed**            | `Add R3, (R1+R2)`       | `Regs[R3] <- Regs[R3] + Mem[Regs[R1] + Regs[R2]]`                  | Sometimes useful in array addressing: R1 = base of array; R2 = index amount                                                               |
| **Direct or absolute** | `Add R1, (1001)`1       | `Regs[R1] <- Regs[R1] + Mem[1001]`2                                | Sometimes useful for accessing static data; address constant may need to be large3                                                        |
| **Memory indirect**    | `Add R1, @(R3)`5        | `Regs[R1] <- Regs[R1] + Mem[Mem[Regs[R3]]]`6                       | If R3 is the address of a pointer _p_, then mode yields *_p_                                                                              |
| **Autoincrement**      | `Add R1, (R2)+`         | `Regs[R1] <- Regs[R1] + Mem[Regs[R2]]; Regs[R2] <- Regs[R2] + d`   | Useful for stepping through arrays within a loop. R2 points to start of array; each reference increments R2 by _size_ of an element, _d8_ |
| **Autodecrement**      | `Add R1, -(R2)`10       | `Regs[R2] <- Regs[R2] - d; Regs[R1] <- Regs[R1] + Mem[Regs[R2]]`11 | Same use as autoincrement. Autodecrement/-incremen12t can also act as push/pop to implement a stack.                                      |
| **Scaled**             | `Add R1, 100(R2)[R3]`   | `Regs[R1] <- Regs[R1] + Mem[100 + Regs[R2] + Regs[R3] * d]`        | Used to index arrays. May be applied to any indexed addressing mode in some computers                                                     |
# Frequency of Addressing Modes
The most frequently occuring addressing modes are ***register indirect, immediate, and displacement modes***, making up **75-99%** of all memory references, and newer machines support these modes. 

The next most frequent addressing modes are **scaled and memory indirect**, but they still make up a relatively small portion of all memory modes. 

Other models make up less than 3% of all memory accesses, and are losing support. 