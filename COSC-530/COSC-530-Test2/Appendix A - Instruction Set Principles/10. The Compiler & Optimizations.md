Modern compilers are a link between high-level programming languages and the processor's machine code, or code that the ISA can interpret. A typical optimizing compiler consists of several phases, moving from machine-independent code to highly machine-dependent code. 

1. Front End
	1. Converts the source language into a portable intermediate representation; from here perform high-level machine independent optimizations such as loop unrolling or procedure inlining. 
2. High Level Optimizations
	1. Perform operations such as loop transforming or procedure inlining. 
3. Global Optimizer
	1. Perform register assignment or register allocation at this phase; this results in a program that is no longer portable, but may still use an intermediate form so that code is mostly machine independent. 
4. Code Generator
	1. Generates machine code in a highly machine dependent way; Any optimization at this point will need to be custom written for the architecture. There is little or no optimization done after code generation. 

# Compiler Optimizations
- Goals of compiler optimization
	- Preserve behavior
	- Reduce execution time
	- Decrease code size
	- Reduce energy usage
- Levels of compiler optimizations
	- High-level (In the source code)
		- Performed on source code or high level format; then fed to later stages of compiler.
	- Low level (close to machine level)
		- Replace an operation with a cheaper operation; replace multiplication with a bit shift operation if a multiple of 2. (y*8) == y<<3
	- Local (within a basic block)
		- Replacing a common operand (a-b) with a variable to prevent recomputing.
	- global (across basic blocks)
		- remove values that are recomputed with the same value from loops
	- Inter-procedural (across function boundaries)
