Sections [[6. Control Flow Mechanisms]] [[7. Evaluating Branch Conditions]] & [[8. Calling Conventions]] discuss various design choices with various tradeoffs, and impact how we might encode an instruction set into a binary representation. These tradeoffs include Complexity vs Code size, decoding simplicity, and performance. 

1. More registers and addressing modes could benefit performance, but requires more bits for encoding. 
2. Simple formats are easier to decode, but require more instructions than complex formats.
3. Fixed size instructions simplify the fetch unit and pipelining, but variable size instructions require less space. 

There are *Three* basic variations for encoding an instruction set:

1. Variable Length Encoding
	1. Instructions have different lengths, allowing for flexibility where operations can be combined. 
	2. Used in VAX, x86, and CISC architectures
2. Fixed Length Encodings
	1. All Instructions have a fixed length, and addressing mode and operations are combined into a single opcode. Simpler to build, and works well where there are fewer operations.
	2. Used in RISC V, MIPS, & SPARC
3. Hybrid Encodings
	1. Attempts to reduce variability in variable length encoding, but allows some different instruction lengths to reduce code size. Some support an instruction set with "narrow" 16-bit instructions and regular 32 bit instructions

![[Pasted image 20251111155715.png]]