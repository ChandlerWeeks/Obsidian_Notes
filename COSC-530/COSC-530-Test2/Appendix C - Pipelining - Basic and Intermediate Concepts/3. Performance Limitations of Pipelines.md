In an ideal pipeline, performance will improve by a factor of the number of stages in the pipeline, but in reality various elements limit the amount of improvement seen by pipelining. These elements that hinder improvements are

- Pipeline overhead due to passing information through the registers.
- imbalance between pipeline stages. 
	- the pipeline can only run as fast as the slowest pipeline stage. IF, MEM, & EX are usually the limitation for other pipeline stages. 
- pipeline hazards
	- Structural hazards - resource conflicts
		- The processor cannot support all possible combinations of instructions simultaneously in overlapped execution. Usually occur in functional units like FP. 
	- Data hazards - result dependencies
		- an instruction relies on the results of a previous instruction, and the overlapped execution in the pipeline prevents the results from being available. 
	- Control hazards - changing the program counter
		- Control flow shit changes the program counter and everything dies and explodes </3

# Stalls

Pipeline hazards cause stalls, which delays all instructions on the branch which is running. Using a simple derivation, we can account for stalls through the following formula:

Speedup in Pipeline (with stalls) = 
(pipeline depth) / (1 + pipeline stall cycles per instruction)

# More on Structural Hazards
Structural hazards occur when a resource is needed, but not available. They occur when:
- Some functional unit is not fully pipelined
- not enough resources are available to accommodate all possible instruction combinations.

A question which may arise is why not design processors to always avoid structural hazards:
- Some hazards are rare, so the costs outweighs the benefits. 
- Unpipelined units might produce results more quickly by preventing overhead

Example: instructions and data are stored in memory, so IF could rely on the same unit as MEM. This is why two caches are used for instructions and data. 

![[Pasted image 20251111181559.png]]
*Example of the effects a stall has*