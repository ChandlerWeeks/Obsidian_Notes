Static Branch Prediction: Branch Predicted only by the compiler
Semi-Static branch Prediction: Branch Predicted by the compiler and a program profile
Dynamic branch Prediction: Branch predicted by hardware at runtime

# Static & Semi-Static Branch Prediction
Aim to assist dynamic branch prediction with default branch prediction. These guide compiler optimizations, include instruction scheduling, code duplication for frequent paths, code re-organization to reduce branching. 

Strictly static branch prediction just looks at the program structure, and uses a heuristic to decide whether a branch should be predicted as taken or not. \
![[Pasted image 20251111201347.png]]
Oftentimes, the heuristic is to avoid predict forward branches (breaks out of loops, error conditions). Because of this, 4 & 3 are likely to loop, and 1 is likely to move towards 2. This results in decent accuracy, with about 15% misprediction with float point benchmarks, but still has very limited accuracy. 

# Dynamic Branch Prediction
- Uses hardware cache to record program branches
	- Indexed by lower portion of the branch address. 
	- Contains bits indicating if the branch was taken, or fell through. 
- Does **NOT** need tag bits to be useful. If the branch history corresponds to the wrong program instruction the pipeline may mispredict the branch more frequently. 
- Branch prediction buffers with only one bit of history can be useful, but extra history can be useful. 
- Fairly accurate with little memory overhead. 

**NOTE**: Even if this approach has high accuracy, the processor might still need to stall if the target address is unknown at the time of prediction. 

## 1-bit Branch Prediction Buffer
Each entry in the buffer contains a single bit indicating if the branch was last taken or not taken, if its wrong the bit is inverted. 

For (i = 0; i < 100; i++) // B1
	if (i & 1) // B2

B2 is mispredicted every time, since it predicts the wrong event every time, but B1 is right until the loop is exited. 

## 2-bit Branch Prediction Buffer
Each branch prediction buffer gets an extra bit of history; for the same function B1 is only mispredicted once, again, and B2 is only wrong 50% of the time. 

![[Pasted image 20251111204954.png]]


