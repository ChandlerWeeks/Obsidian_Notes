**Pipelining** is an implementation technique where multiple instructions get overlapped in execution; this allows multiple instructions to run concurrently. 

Time per instruction with ideal pipeline = 
(time per instruction on unpipelined machine) / (number of pipe stages)

Its like a assembly line for a car; the seats, windows, wheels, and doors are all made in parallel, and the car moves forward in the assembly line ready for the next step while the previous car is worked on. 

Each step in the pipeline, called a pipe step or pipe segment completes a different part of the instruction. The different steps operate on different instructions in parallel. The steps are hooked together, so that each instruction proceeds from one pipe step to the next; the time to move an instruction through the pipeline is called a processor cycle, and each cycle is a factor of the slowest step in the process. 

The goal of pipelining is to maximize **throughput**, since the pipeline steps take the same amount of time as unpipelined steps, the time needed for instruction can be reduced by a factor of the number of pipelining stages. 

# RISC-V Pipeline Stages

1. Instruction Fetch (IF) : Fetch the instruction from the IC, increment the PC
2. Instruction Decode (ID) : Decode the instruction, determining necessary registers, or operands necessary to run the instruction;
3. Execution (EX): The ALU operates on the operands prepared in the ID stage; the ID stage also sends a code which tells it which operation to perform;
4. Memory Access (MEM): Load a value or store a value into the Data Cache & memory. 
5. Write Back (WB): update the register with the result of an operation (ALU) or a memory load

![[Pasted image 20251111173802.png]]

# Structural Hazards
If two instructions happen to be in stages that both need the same shared hardware resource in the same clock cycle, a conflict arises. While the ALU is a clear example, structural hazards arize from shared memory components; 