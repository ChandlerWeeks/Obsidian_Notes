All approaches thus far have discussed eliminating stalls to make the number of CPI as close to one as possible. To make the CPI less than 1, we need to issue multiple instructions per cycle.

There are three methods to approach this issue
1. Statically scheduled superscalar
2. Very long instruction word
3. Dynamically scheduled superscalar

Issuing multiple instructions in parallel requires simultaneous actions to be performed for multiple instructions
- Fetching
- Decoding
- Executing
- Accessing memory
- Writing Results

# Statically Scheduled Superscalar Approach
- Issue varying number of instructions that can be quickly detected as independent.
- Typically, issue at most 2 to 4 instructions per clock cycle.
- If an instruction has a dependency, only the preceding instructions will be issued. 
- More likely to have hazards causing stalls.
- No increase in code size and less work for compiler
- Programs compiled from nonsuperscalar machines will still execute and have benefits. 

TLDR: These processors issue multiple instructions in each clock, and then do quick checks to determine if instructions are actually independent. Because instructions are issued close together, there is a higher chance of stalls. 

# Very Long Instruction Word Approach (VLIW)
- Compiler packages multiple independent operations into a single, very long instruction. (2-32 words)
- Instructions in the packet execute in parallel using multiple function units. 
- Simplifies issuing hardware
- With many functional units, relies on the compiler to exploit ILP
	- Loop unrolling
	- Software pipelining
	- superblock scheduling

![[Pasted image 20251112172747.png]]
*Example VLIW Instructions

**Chalenges with VLIW**:
- performing multiple loads and stores in the same cycle
- multiple accesses to the register file in the same cycle
- clock cycle may have to be lengthened
- May significantly increase code size due to extra space for loops and code duplication to extract parallelism. 
- Any function unit stalls cause the entire processor to stall
- Different implementations (number of functional units) can break binary compatibility. 

# Dynamically scheduled superscalar approach
- Simultaneously fetch multiple instructions
- issue multiple instructions in the same cycle
- write multiple results on the CDB in the same cycle
- Commit multiple Instructions in the same cycle

Basically, this uses the same parts of speculative tomasulo's algorithm but adds hardware to simultaneously fetch multiple instructions, issue multiple instructions, write multiple results on the CDB, and commit multiple instructions all in the same cycle. 

![[Pasted image 20251112174003.png]]
*Dual issue version of Tomasulo's algorithm using DSSA*