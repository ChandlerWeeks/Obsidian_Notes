Dynamic scheduling in which hardware reorders program instructions to reduce pipeline stalls, while still maintaining data flow and exception behavior, unlike [[2. Static Scheduling]] which is based upon software and compiler. 

**Advantages**:
1. Code compiled for one pipeline can run efficiently on another pipeline. Applications are distributed as binaries, so not having to recompile code in great. 
2. It enables handling cases where dependencies may not be known at compile time; 
3. The processor can tolerate unpredictable delays, such as cache misses, by executing instructions while waiting for delays to be resolved. 

**Disadvantages**:
	Complicates hardware design, requiring more energy and a possibly longer cycle time. 

# Out-of-order Execution
Dynamic Scheduling allows OoO execution
- With dynamic scheduling, another component can run while another stalls
Splits ID stage into two stages:
1. Issue - decode instructions, check for structural hazards
2. Read operands - wait until no data hazards, then read
OoO can result in OoO completion, which complicates exceptions

**Issues**:
- OoO introduces the possibility of WAR & WAW hazards

**Solutions**:
- Scoreboarding - No register renaming, cannot remove WAR / WAW hazards
- Tomasulo's algorithm - Removes WAR / WAW hazards with register renaming, can be extended to handle speculation. 