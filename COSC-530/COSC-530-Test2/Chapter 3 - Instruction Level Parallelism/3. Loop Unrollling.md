To show an example of [[2. Static Scheduling]] in play, an example is loop unrolling a simple loop. 

Given the simple loop 
for (i = 999; i >= 0; i = i - 1) {
	x[i] = x[i] + s
}

We are given the RISC V code

|**Line**|**Instruction**|
|---|---|
|`Loop:`|`fld f0,0(x1)`|
||`fadd.d f4,f0,f2`|
||`fsd f4,0(x1)`|
||`addi x1,x1,-8`|
||`bne x1,x2,Loop`|

With stalls it looks something like this

|**Line**|**Instruction**|
|---|---|
|`Loop:`|`fld f0,0(x1)`|
||`stall`|
||`fadd.d f4,f0,f2`|
||`stall`|
||`stall`|
||`fsd f4,0(x1)`|
||`addi x1,x1,-8`|
||`bne x1,x2,Loop`|

But we can remove a stall by scheduling the addi operation earlier, since it does not have a dependency. 

|**Line**|**Instruction**|
|---|---|
|`Loop:`|`fld f0,0(x1)`|
||`addi x1,x1,-8`|
||`fadd.d f4,f0,f2`|
||`stall`|
||`stall`|
||`fsd f4,8(x1)`|
||`bne x1,x2,Loop`|

# Loop Unrolling at Source Code Level

for (i = 0; i < n; i++) {
	a[i] = a[i] + x;
}

1. Loop unrolling duplicates the body of the loop some number of times to reduce branch overhead;

unroll factor = 4

// instead of doing the operation each iteration, do it 4 times on iterations of 4; 
for (i = 0; i < n % 4; i++) // handle extra iterations if number of iterations is not divisible by unroll factor
	a[i] = a[i] + x;
for (; i < n; i++) {
	a[i] = a[i] + x;
	a[i+1] = a[i+1] + x;
	a[i+2] = a[i+2] + x;
	a[i+3] = a[i+3] + x;
}

// reduce iterations, comparisons
for (i = 0; i < n % 4; i++) // handle first n % 4 values
	a[i] = a[i] + x;
for (; i < n; i+=4) {
	a[i] = a[i] + x;
	a[i+1] = a[i+1] + x;
	a[i+2] = a[i+2] + x;
	a[i+3] = a[i+3] + x;
}

# Loop unrolling at assembly level

![[Pasted image 20251112113241.png]]